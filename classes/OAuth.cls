/**
* The OAuth file implements a class to sign easily
* HttpRequests using OAuth 1.0 with HMAC-SHA1 as signature
* method.
* @author  		Daniel Palacios Hidalgo
* @version 		1.0
* @since    	2019-06-03 
* @testClass 	OAuthTest
*/
public class OAuth {
    public class OAuthParam implements Comparable {
        private String key;
        private String value;
        private String encodedKey;
        private String encodedValue;
        private Boolean isOAuthData;
        
        public OAuthParam(String key, String value, Boolean oAuthData) {
            this.key = key;
            this.value = value;
            this.encodedKey = EncodingUtil.urlEncode(key, 'UTF-8');
            this.encodedValue = EncodingUtil.urlEncode(value, 'UTF-8');
            this.isOAuthData = oAuthData;
        }
        
        public Integer compareTo(Object obj) {
			OAuthParam p = (OAuthParam) obj;
        	if (this.encodedKey > p.encodedKey) return 1;
            if (this.encodedKey == p.encodedKey) return 0;
            return -1;
    	}
        
        public string getKey() {
            return key;
        }
        
        public string getEncodedKey() {
            return encodedKey;
        }
        
        public string getValue() {
            return value;
        }
        
        public string getEncodedValue() {
            return encodedValue;
        }
        
        public boolean getIsOAuthData() {
            return isOAuthData;
        }
        
    }
    
	private String consumerKey;
    private String consumerSecret;
    private String oAuthToken;
    private String accessTokenSecret;
    private String oAuthVersion = '1.0';
	private final String signatureMethod = 'HMAC-SHA1';
    
    /**
   	* Constructor
	* @param consumerKey key of the consumer.
	* @param consumerSecret secret of the consumer.
	* @param oAuthToken OAuth 1.0 token.
	* @param accessTokenSecret Secret access token.
   	* @return String string to be signed.
   	*/
    public OAuth(String consumerKey, String consumerSecret, String oAuthToken, String accessTokenSecret) {
        this.consumerKey = consumerKey;
        this.consumerSecret = consumerSecret;
        this.oAuthToken = oAuthToken;
        this.accessTokenSecret = accessTokenSecret;
    }
    
    /**
   	* This method returns the param string to be used to
	* construct the base string.
	* @param paramList list of OAuth parameters.
   	* @return String string to be concatenated.
   	*/
    @testVisible
    private static String getParamString(List<OAuthParam> paramList) {
        String paramString = '';
        paramList.sort();
        
        for(Integer i=0; i < paramList.size(); i++) {
            paramString += paramList[i].encodedKey + '=' + paramList[i].encodedValue;
            if(i < paramList.size() - 1)
                paramString += '&';
        }
        
        return paramString;
    }
    
    /**
   	* This method returns the base string to be signed.
	* @param method method of the http request.
	* @param url base url of the http request.
	* @param paramString string of parameters, UTF-8 encoded,
	*		 and sorted alphabetically by key [& value];
   	* @return String string to be signed.
   	*/
    @testVisible
    private static String getBaseString(String method, String url, String paramString) {
        String baseString = '';
        
        baseString += method.toUpperCase() + '&';
        baseString += EncodingUtil.urlEncode(url, 'UTF-8') + '&';
        baseString += EncodingUtil.urlEncode(paramString, 'UTF-8');
        
        return baseString;
    }
    
    /**
   	* This method returns the list of OAuth params.
	* @param url url to extract the params from.
	* @param nonce unique, autogenerated value.
	* @param timestamp current timestamp when the signature
			 takes place.
   	* @return List<OAuthParam> param list.
   	*/
    @testVisible
    private List<OAuthParam> getOAuthParamList(Url url, String nonce, String timestamp) {
        List<OAuthParam> paramList = new List<OAuthParam>();   
        
        // Get URL query params
        String urlQuery = url.getQuery();
        if(urlQuery <> null){
            if(urlQuery.contains('?')) urlQuery = urlQuery.remove('?');
            List<String> splittedQuery = urlQuery.split('&');
            String[] splittedParam;
            
            for(String s: splittedQuery) {
                splittedParam = s.split('=');
                paramList.add(new OAuthParam(splittedParam[0], splittedParam[1], false));
            }
        }
        
        // Set oAuth 1.0 params
		paramList.add(new OAuthParam('oauth_consumer_key', consumerKey, true));
		paramList.add(new OAuthParam('oauth_nonce', nonce, true)); 
        paramList.add(new OAuthParam('oauth_signature_method', signatureMethod, true)); 
        paramList.add(new OAuthParam('oauth_timestamp', timestamp, true)); 
        paramList.add(new OAuthParam('oauth_token', oAuthToken, true)); 
        paramList.add(new OAuthParam('oauth_version', oAuthVersion, true)); 
        
        paramList.sort();
        return paramList;
    }
    
    /**
   	* This method returns the base url of an endpoint.
	* @param url url to extract the endpoint from.
   	* @return String base url.
   	*/
    @testVisible
    private string getBaseUrl(Url u) {
		String stringUrl = u.toExternalForm();
        if(stringUrl.contains('?'))
            stringUrl = stringUrl.split('\\?')[0];
		
        return stringUrl;
    }
    
    /**
   	* This method generates the signature according to
	* an input and a signing key.
	* @param input input string to be signed.
	* @param signingKey key to sign.
   	* @return String signature.
   	*/
    @testVisible
    private string HMACSHA1(String input, String signingKey) {
		Blob signature = Crypto.generateMac('HmacSHA1', Blob.ValueOf(input), Blob.ValueOf(signingKey));
		return EncodingUtil.base64encode(signature);
    }
    
    /**
   	* This method generates the signing key according to
	* the consumer secret and the secret access token.
   	* @return String signing key.
   	*/
    @testVisible
    private string generateSigningKey() {
        return EncodingUtil.urlEncode(consumerSecret, 'UTF-8') +'&'+ EncodingUtil.urlEncode(accessTokenSecret, 'UTF-8');
    }
    
    /**
   	* This method signs the HttpRequest according to
	* OAuth 1.0 param list and the signature.
   	* @param req 		HttpRequest to be signed
	* @param paramList 	List of OAuth parameters to
	*					be included in the request header
	* @param signature	HMAC-SHA1 encoded signature.
   	* @return HttpRequest signed.
   	*/
    private HttpRequest signRequest(HttpRequest req, List<OAuthParam> paramList, String signature) {
        OAuthParam param;
        String authorization = 'OAuth ';
        Integer params = 0;
        for(Integer i=0; i < paramList.size(); i++) {
            param = paramList[i];
            
            if(params == 0 && param.isOAuthData){
                authorization += param.key + '= "' + param.value + '"';
                params++;
            } else if(params <> 0 && param.isOAuthData){
                authorization += ', ' + param.key + '= "' + param.value + '"';
                params++;
            }
        }
        
		authorization += ', oauth_signature="' + signature + '"';
		req.setHeader('Authorization', authorization);      
        return req;
    }
    
   /**
   	* This method orchestrates the signature of an http request
   	* @param req HttpRequest to be signed
   	* @return HttpRequest signed.
   	*/
    public HttpRequest sign(HttpRequest req) {
        Url url = new Url(req.getEndpoint());
        String httpMethod = req.getMethod();
        
        // Force non-random parameters for testing contexts.
        String nonce = (Test.isRunningTest()) ? 'kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg' : String.valueOf(Crypto.getRandomLong());
        String timestamp = (Test.isRunningTest()) ? '1318622958' : String.valueOf(Datetime.now().getTime());

        List<OAuthParam> paramList = getOAuthParamList(url, nonce, timestamp);
        String paramString = getParamString(paramList);
		String baseString = getBaseString(httpMethod, getBaseUrl(url), paramString);  
        
        String signingKey = generateSigningKey();
        String signature = HMACSHA1(baseString, signingKey);
        
        return signRequest(req, paramList, signature);
    }
}